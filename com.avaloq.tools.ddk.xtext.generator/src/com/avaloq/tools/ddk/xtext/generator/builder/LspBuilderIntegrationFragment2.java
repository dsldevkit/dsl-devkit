/*******************************************************************************
 * Copyright (c) 2016 Avaloq Group AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Group AG - initial API and implementation
 *******************************************************************************/

package com.avaloq.tools.ddk.xtext.generator.builder;

import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.osgi.util.NLS;
import org.eclipse.xtext.AbstractMetamodelDeclaration;
import org.eclipse.xtext.GeneratedMetamodel;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.xtext.generator.AbstractXtextGeneratorFragment;
import org.eclipse.xtext.xtext.generator.XtextGeneratorNaming;
import org.eclipse.xtext.xtext.generator.model.FileAccessFactory;
import org.eclipse.xtext.xtext.generator.model.TypeReference;
import org.eclipse.xtend2.lib.StringConcatenationClient;

import com.google.inject.Inject;


public class LspBuilderIntegrationFragment2 extends AbstractXtextGeneratorFragment {

  private static final Logger LOGGER = LogManager.getLogger(LspBuilderIntegrationFragment2.class);

  @Inject
  private FileAccessFactory fileAccessFactory;

  @Inject
  private XtextGeneratorNaming packageNaming;

  private TypeReference createSuffixedTypeReference(String suffix) {
    return new TypeReference(
      packageNaming.getGenericIdeBasePackage(getGrammar()), GrammarUtil.getSimpleName(getGrammar()) + suffix
    );
  }

  protected TypeReference getLspBuildSetupGeneratedClass() {
    return createSuffixedTypeReference("LspBuildSetupGenerated");
  }

  protected TypeReference getLspBuildSetupServiceClass() {
    return createSuffixedTypeReference("LspBuildSetupService");
  }

  @Override
  public void generate() {
    if (getProjectConfig().getGenericIde().isEnabled()) {
      if (LOGGER.isInfoEnabled()) {
        LOGGER.info(NLS.bind("executing generate for {0}", getClass().getName()));
      }
      generateServiceRegistration();
      generateBuildService();
      generateBuildSetup();
    }
  }

  public void generateServiceRegistration() {
    StringBuilder sb = new StringBuilder();
    sb.append(getLspBuildSetupServiceClass().getName());
    sb.append("\n");
    fileAccessFactory.createTextFile("META-INF/services/com.avaloq.tools.ddk.xtext.build.ILspLanguageSetup",
      toClient(sb)).writeTo(getProjectConfig().getGenericIde().getSrcGen());
  }

  public void generateBuildService() {
    Grammar grammar = getGrammar();
    TypeReference lspBuildSetupServiceClass = getLspBuildSetupServiceClass();
    StringBuilder sb = new StringBuilder();
    sb.append("import java.util.List;\n");
    sb.append("\n");
    sb.append("import com.avaloq.tools.ddk.xtext.build.AbstractDynamicSetupService;\n");
    sb.append("import com.avaloq.tools.ddk.xtext.build.ILspLanguageSetup;\n");
    sb.append("import com.google.common.collect.ImmutableList;\n");
    sb.append("import com.google.inject.Injector;\n");
    sb.append("import com.google.inject.Module;\n");
    sb.append("\n");
    sb.append("/**\n");
    sb.append(" * Generated by com.avaloq.tools.ddk.xtext.generator.builder.LspBuilderIntegrationFragment2.\n");
    sb.append(" */\n");
    sb.append("public class ").append(lspBuildSetupServiceClass.getSimpleName()).append(" extends AbstractDynamicSetupService implements ILspLanguageSetup {\n");
    sb.append("\n");
    sb.append("  @SuppressWarnings(\"nls\")\n");
    sb.append("  private static final String GRAMMAR = \"").append(grammar.getName()).append("\";\n");
    sb.append("  @SuppressWarnings(\"nls\")\n");
    sb.append("  private static final List<String> PARENTS = ImmutableList.of(//\n");
    List<Grammar> allUsedGrammars = GrammarUtil.allUsedGrammars(grammar);
    for (int i = 0; i < allUsedGrammars.size(); i++) {
      Grammar g = allUsedGrammars.get(i);
      sb.append("     \"").append(g.getName()).append("\" //");
      if (i < allUsedGrammars.size() - 1) {
        sb.append(",");
      }
      sb.append("\n");
    }
    sb.append("  );\n");
    sb.append("\n");
    sb.append("  public Injector doSetup(Module overrideModule, Module... additionalModules) {\n");
    sb.append("    return new ").append(GrammarUtil.getSimpleName(grammar)).append("LspBuildSetupGenerated(SETUP_LOCK, overrideModule, additionalModules).createInjectorAndDoEMFRegistration();\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public List<String> getParentLanguages() {\n");
    sb.append("    return PARENTS;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public String getLanguageName() {\n");
    sb.append("    return GRAMMAR;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("}\n");
    fileAccessFactory.createJavaFile(lspBuildSetupServiceClass,
      toClient(sb)).writeTo(getProjectConfig().getGenericIde().getSrcGen());
  }

  public void generateBuildSetup() {
    Grammar grammar = getGrammar();
    TypeReference lspBuildSetupGeneratedClass = getLspBuildSetupGeneratedClass();
    StringBuilder sb = new StringBuilder();
    sb.append("import org.eclipse.xtext.util.Modules2;\n");
    sb.append("\n");
    sb.append("import com.google.common.collect.ImmutableList;\n");
    sb.append("import com.google.inject.Guice;\n");
    sb.append("import com.google.inject.Injector;\n");
    sb.append("import com.google.inject.Module;\n");
    sb.append("import com.google.inject.util.Modules;\n");
    sb.append("\n");
    sb.append("\n");
    sb.append("/**\n");
    sb.append(" * Generated by com.avaloq.tools.ddk.xtext.generator.builder.LspBuilderIntegrationFragment2.\n");
    sb.append(" */\n");
    sb.append("public class ").append(lspBuildSetupGeneratedClass.getSimpleName()).append(" extends ").append(packageNaming.getGenericIdeSetup(grammar)).append(" {\n");
    sb.append("\n");
    sb.append("  private final Module overrideModule;\n");
    sb.append("  private final Module[] additionalModules;\n");
    sb.append("  private final Object lock;\n");
    sb.append("\n");
    sb.append("  public ").append(lspBuildSetupGeneratedClass.getSimpleName()).append("(final Object lock, final Module overrideModule, Module... additionalModules) {\n");
    sb.append("    this.lock = lock;\n");
    sb.append("    this.overrideModule = overrideModule;\n");
    sb.append("    this.additionalModules = additionalModules;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  public ").append(lspBuildSetupGeneratedClass.getSimpleName()).append("(final Module overrideModule, Module... additionalModules) {\n");
    sb.append("    this.lock = null;\n");
    sb.append("    this.overrideModule = overrideModule;\n");
    sb.append("    this.additionalModules = additionalModules;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public Injector createInjectorAndDoEMFRegistration() {\n");
    sb.append("    registerEPackages();\n");
    sb.append("    Injector injector = createInjector();\n");
    sb.append("    if (lock != null) {\n");
    sb.append("      synchronized (lock)  {\n");
    sb.append("        register(injector);\n");
    sb.append("      }\n");
    sb.append("    } else {\n");
    sb.append("      register(injector);\n");
    sb.append("    }\n");
    sb.append("    return injector;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public Injector createInjector() {\n");
    sb.append("    return Guice.createInjector(getModules());\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  protected void registerEPackages() {\n");
    for (AbstractMetamodelDeclaration decl : grammar.getMetamodelDeclarations()) {
      if (decl instanceof GeneratedMetamodel) {
        GeneratedMetamodel mmd = (GeneratedMetamodel) decl;
        String ns = GrammarUtil.getNamespace(grammar);
        String name = mmd.getName();
        String nameUpper = name.substring(0, 1).toUpperCase() + name.substring(1);
        sb.append("    if (").append(ns).append(".").append(name).append(".").append(nameUpper).append("Package.eINSTANCE == null) {\n");
        sb.append("      throw new IllegalStateException(\"EPackage could not be initialized: \" + ").append(ns).append(".").append(name).append(".").append(nameUpper).append("Package.eNS_URI); //$NON-NLS-1$\n");
        sb.append("    }\n");
      }
    }
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  protected Iterable<Module> getModules() {\n");
    sb.append("    return ImmutableList.<Module> builder().add(Modules.override(Modules2.mixin(new ").append(grammar.getName()).append("RuntimeModule(), new ").append(packageNaming.getGenericIdeModule(grammar)).append("())).with(overrideModule)).add(additionalModules).build();\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("}\n");
    fileAccessFactory.createJavaFile(lspBuildSetupGeneratedClass,
      toClient(sb)).writeTo(getProjectConfig().getGenericIde().getSrcGen());
  }

  private static StringConcatenationClient toClient(final StringBuilder sb) {
    final String content = sb.toString();
    return new StringConcatenationClient() {
      @Override
      protected void appendTo(TargetStringConcatenation target) {
        target.append(content);
      }
    };
  }

}
