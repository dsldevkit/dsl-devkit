/*******************************************************************************
 * Copyright (c) 2016 Avaloq Group AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Group AG - initial API and implementation
 *******************************************************************************/

package com.avaloq.tools.ddk.xtext.generator.builder;

import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.eclipse.osgi.util.NLS;
import org.eclipse.xtext.AbstractMetamodelDeclaration;
import org.eclipse.xtext.GeneratedMetamodel;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.xtext.generator.AbstractXtextGeneratorFragment;
import org.eclipse.xtext.xtext.generator.model.FileAccessFactory;
import org.eclipse.xtext.xtext.generator.model.TypeReference;
import org.eclipse.xtend2.lib.StringConcatenationClient;

import com.google.inject.Inject;


public class StandaloneBuilderIntegrationFragment2 extends AbstractXtextGeneratorFragment {

  private static final Logger LOGGER = LogManager.getLogger(StandaloneBuilderIntegrationFragment2.class);

  @Inject
  private FileAccessFactory fileAccessFactory;

  private TypeReference createSuffixedTypeReference(String suffix) {
    return new TypeReference(
      getGrammar().getName() + suffix
    );
  }

  protected TypeReference getStandaloneBuildSetupGeneratedClass() {
    return createSuffixedTypeReference("StandaloneBuildSetupGenerated");
  }

  protected TypeReference getStandaloneBuildSetupServiceClass() {
    return createSuffixedTypeReference("StandaloneBuildSetupService");
  }

  @Override
  public void generate() {
    if (LOGGER.isInfoEnabled()) {
      LOGGER.info(NLS.bind("executing generate for {0}", getClass().getName()));
    }
    generateServiceRegistration();
    generateBuildService();
    generateBuildSetup();
  }

  public void generateServiceRegistration() {
    StringBuilder sb = new StringBuilder();
    sb.append(getStandaloneBuildSetupServiceClass().getName());
    sb.append("\n");
    fileAccessFactory.createTextFile("META-INF/services/com.avaloq.tools.ddk.xtext.build.IDynamicSetupService",
      toClient(sb)).writeTo(getProjectConfig().getRuntime().getSrcGen());
  }

  public void generateBuildService() {
    Grammar grammar = getGrammar();
    TypeReference standaloneBuildSetupServiceClass = getStandaloneBuildSetupServiceClass();
    StringBuilder sb = new StringBuilder();
    sb.append("import java.util.List;\n");
    sb.append("\n");
    sb.append("import com.avaloq.tools.ddk.xtext.build.AbstractDynamicSetupService;\n");
    sb.append("import com.google.common.collect.ImmutableList;\n");
    sb.append("import com.google.inject.Injector;\n");
    sb.append("import com.google.inject.Module;\n");
    sb.append("\n");
    sb.append("/**\n");
    sb.append(" * Generated by com.avaloq.tools.ddk.xtext.generator.builder.StandaloneBuilderIntegrationFragment2.\n");
    sb.append(" */\n");
    sb.append("public class ").append(standaloneBuildSetupServiceClass.getSimpleName()).append(" extends AbstractDynamicSetupService {\n");
    sb.append("\n");
    sb.append("  @SuppressWarnings(\"nls\")\n");
    sb.append("  private static final String GRAMMAR = \"").append(grammar.getName()).append("\";\n");
    sb.append("  @SuppressWarnings(\"nls\")\n");
    sb.append("  private static final List<String> PARENTS = ImmutableList.of(//\n");
    List<Grammar> allUsedGrammars = GrammarUtil.allUsedGrammars(grammar);
    for (int i = 0; i < allUsedGrammars.size(); i++) {
      Grammar g = allUsedGrammars.get(i);
      sb.append("     \"").append(g.getName()).append("\" //");
      if (i < allUsedGrammars.size() - 1) {
        sb.append(",");
      }
      sb.append("\n");
    }
    sb.append("  );\n");
    sb.append("\n");
    sb.append("  public Injector doSetup(Module overrideModule, Module... additionalModules) {\n");
    sb.append("    return new ").append(GrammarUtil.getSimpleName(grammar)).append("StandaloneBuildSetupGenerated(SETUP_LOCK, overrideModule, additionalModules).createInjectorAndDoEMFRegistration();\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public List<String> getParentLanguages() {\n");
    sb.append("    return PARENTS;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public String getLanguageName() {\n");
    sb.append("    return GRAMMAR;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("}\n");
    fileAccessFactory.createJavaFile(standaloneBuildSetupServiceClass,
      toClient(sb)).writeTo(getProjectConfig().getRuntime().getSrcGen());
  }

  public void generateBuildSetup() {
    Grammar grammar = getGrammar();
    TypeReference standaloneBuildSetupGeneratedClass = getStandaloneBuildSetupGeneratedClass();
    StringBuilder sb = new StringBuilder();
    sb.append("import com.google.common.collect.ImmutableList;\n");
    sb.append("import com.google.inject.Guice;\n");
    sb.append("import com.google.inject.Injector;\n");
    sb.append("import com.google.inject.Module;\n");
    sb.append("import com.google.inject.util.Modules;\n");
    sb.append("\n");
    sb.append("\n");
    sb.append("/**\n");
    sb.append(" * Generated by com.avaloq.tools.ddk.xtext.generator.builder.StandaloneBuilderIntegrationFragment2.\n");
    sb.append(" */\n");
    sb.append("public class ").append(standaloneBuildSetupGeneratedClass.getSimpleName()).append(" extends ").append(GrammarUtil.getSimpleName(grammar)).append("StandaloneSetup {\n");
    sb.append("\n");
    sb.append("  private final Module overrideModule;\n");
    sb.append("  private final Module[] additionalModules;\n");
    sb.append("  private final Object lock;\n");
    sb.append("\n");
    sb.append("  public ").append(standaloneBuildSetupGeneratedClass.getSimpleName()).append("(final Object lock, final Module overrideModule, Module... additionalModules) {\n");
    sb.append("    this.lock = lock;\n");
    sb.append("    this.overrideModule = overrideModule;\n");
    sb.append("    this.additionalModules = additionalModules;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  public ").append(standaloneBuildSetupGeneratedClass.getSimpleName()).append("(final Module overrideModule, Module... additionalModules) {\n");
    sb.append("    this.lock = null;\n");
    sb.append("    this.overrideModule = overrideModule;\n");
    sb.append("    this.additionalModules = additionalModules;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public Injector createInjectorAndDoEMFRegistration() {\n");
    sb.append("    registerEPackages();\n");
    sb.append("    Injector injector = createInjector();\n");
    sb.append("    if (lock != null) {\n");
    sb.append("      synchronized (lock)  {\n");
    sb.append("        register(injector);\n");
    sb.append("      }\n");
    sb.append("    } else {\n");
    sb.append("      register(injector);\n");
    sb.append("    }\n");
    sb.append("    return injector;\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  @Override\n");
    sb.append("  public Injector createInjector() {\n");
    sb.append("    return Guice.createInjector(getModules());\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  protected void registerEPackages() {\n");
    for (AbstractMetamodelDeclaration decl : grammar.getMetamodelDeclarations()) {
      if (decl instanceof GeneratedMetamodel) {
        GeneratedMetamodel mmd = (GeneratedMetamodel) decl;
        String ns = GrammarUtil.getNamespace(grammar);
        String name = mmd.getName();
        String nameUpper = name.substring(0, 1).toUpperCase() + name.substring(1);
        sb.append("    if (").append(ns).append(".").append(name).append(".").append(nameUpper).append("Package.eINSTANCE == null) {\n");
        sb.append("      throw new IllegalStateException(\"EPackage could not be initialized: \" + ").append(ns).append(".").append(name).append(".").append(nameUpper).append("Package.eNS_URI); //$NON-NLS-1$\n");
        sb.append("    }\n");
      }
    }
    sb.append("  }\n");
    sb.append("\n");
    sb.append("  protected Iterable<Module> getModules() {\n");
    sb.append("    return ImmutableList.<Module> builder().add(Modules.override(new ").append(grammar.getName()).append("RuntimeModule()).with(overrideModule)).add(additionalModules).build();\n");
    sb.append("  }\n");
    sb.append("\n");
    sb.append("}\n");
    fileAccessFactory.createJavaFile(standaloneBuildSetupGeneratedClass,
      toClient(sb)).writeTo(getProjectConfig().getRuntime().getSrcGen());
  }

  private static StringConcatenationClient toClient(final StringBuilder sb) {
    final String content = sb.toString();
    return new StringConcatenationClient() {
      @Override
      protected void appendTo(TargetStringConcatenation target) {
        target.append(content);
      }
    };
  }

}
