/*******************************************************************************
 * Copyright (c) 2016 Avaloq Evolution AG and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Avaloq Evolution AG - initial API and implementation
 *******************************************************************************/

package com.avaloq.tools.ddk.xtext.generator.builder

import org.apache.log4j.Logger
import org.eclipse.xtext.xtext.generator.AbstractXtextGeneratorFragment
import org.eclipse.osgi.util.NLS
import org.eclipse.xtext.xtext.generator.model.FileAccessFactory
import com.google.inject.Inject

import org.eclipse.xtext.xtext.generator.XtextGeneratorNaming

import static extension org.eclipse.xtext.GrammarUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import org.eclipse.xtext.xtext.generator.model.TypeReference
import org.eclipse.xtext.Grammar
import org.eclipse.xtext.GeneratedMetamodel

class StandaloneBuilderIntegrationFragment2 extends AbstractXtextGeneratorFragment {

	static val LOGGER = Logger.getLogger(StandaloneBuilderIntegrationFragment)

	@Inject FileAccessFactory fileAccessFactory

	@Inject extension XtextGeneratorNaming

	def private TypeReference createSuffixedTypeReference(Grammar g, String suffix) {
		return new TypeReference(
			g.name + suffix
		)
	}

	def protected TypeReference getStandaloneBuildSetupGeneratedClass(Grammar g) {
		createSuffixedTypeReference(g, "StandaloneBuildSetupGenerated")
	}

	def protected TypeReference getStandaloneBuildSetupServiceClass(Grammar g) {
		createSuffixedTypeReference(g, "StandaloneBuildSetupService")
	}

	override generate() {
		if (LOGGER.isInfoEnabled()) {
      		LOGGER.info(NLS.bind("executing generate for {0}", getClass().getName()));
    	}
    	generateServiceRegistration
    	generateBuildService
    	generateBuildSetup
	}

	def generateServiceRegistration() {
		fileAccessFactory.createTextFile("META-INF/services/com.avaloq.tools.ddk.xtext.build.IDynamicSetupService", '''
			«grammar.runtimeBasePackage».«grammar.simpleName»
		''').writeTo(projectConfig.runtime.srcGen)
	}

	def generateBuildService() {
		fileAccessFactory.createJavaFile(grammar.standaloneBuildSetupServiceClass, '''
			import java.util.List;

			import com.google.common.collect.ImmutableList;
			import com.google.inject.Injector;
			import com.google.inject.Module;

			/**
			 * Generated by com.avaloq.tools.ddk.xtext.generator.builder.StandaloneBuilderIntegrationFragment2.
			 */
			public class «grammar.simpleName»StandaloneBuildSetupService extends AbstractDynamicSetupService {

			  @SuppressWarnings("nls")
			  private static final String GRAMMAR = "«grammar.name»";
			  @SuppressWarnings("nls")
			  private static final List<String> PARENTS = ImmutableList.of(//
			     «FOR g: grammar.allUsedGrammars SEPARATOR '
			    ,'»"«g.name»" //«ENDFOR»
			  );

			  public Injector doSetup(Module overrideModule, Module... additionalModules) {
			    return new «grammar.simpleName»StandaloneBuildSetupGenerated(overrideModule, additionalModules).createInjectorAndDoEMFRegistration();
			  }

			  @Override
			  public List<String> getParentLanguages() {
			    return PARENTS;
			  }

			  @Override
			  public String getLanguageName() {
			    return GRAMMAR;
			  }

			}
		''').writeTo(projectConfig.runtime.srcGen)
	}

	def generateBuildSetup() {
		fileAccessFactory.createJavaFile(grammar.standaloneBuildSetupGeneratedClass, '''
			import com.google.common.collect.ImmutableList;
			import com.google.common.collect.Lists;
			import com.google.inject.Guice;
			import com.google.inject.Injector;
			import com.google.inject.Module;
			import com.google.inject.util.Modules;


			/**
			 * Generated by com.avaloq.tools.ddk.xtext.generator.builder.StandaloneBuilderIntegrationFragment.
			 */
			public class «grammar.simpleName»StandaloneBuildSetupGenerated extends «grammar.simpleName»StandaloneSetup {

			  private final Module overrideModule;
			  private final Module[] additionalModules;

			  public «grammar.simpleName»StandaloneBuildSetupGenerated(final Module overrideModule, Module... additionalModules) {
			    this.overrideModule = overrideModule;
			    this.additionalModules = additionalModules;
			  }

			  @Override
			  public Injector createInjectorAndDoEMFRegistration() {
			    registerEPackages();
			    Injector injector = createInjector();
			    register(injector);
			    return injector;
			  }

			  @Override
			  public Injector createInjector() {
			    return Guice.createInjector(getModules());
			  }

			  protected void registerEPackages() {
			  «FOR mmd: grammar.metamodelDeclarations.typeSelect(GeneratedMetamodel)»
			    if («grammar.namespace».«mmd.name».«mmd.name.toFirstUpper()»Package.eINSTANCE == null) {
			      throw new IllegalStateException("EPackage could not be initialized: " + «grammar.namespace».«mmd.name».«mmd.name.toFirstUpper()»Package.eNS_URI); //$NON-NLS-1$
			    }
			  «ENDFOR»
			  }

			  protected Iterable<Module> getModules() {
			    return ImmutableList.<Module> builder().add(Modules.override(new «grammar.name»RuntimeModule()).with(overrideModule)).add(additionalModules).build();
			  }

			}
		''').writeTo(projectConfig.runtime.srcGen)
	}

	//TODO: do we want to keep commented out experimental support for OSGi builder?

}
