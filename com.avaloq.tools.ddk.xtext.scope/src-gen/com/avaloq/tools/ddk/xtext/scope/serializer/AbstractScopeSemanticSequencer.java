/*
 * generated by Xtext
 */
package com.avaloq.tools.ddk.xtext.scope.serializer;

import com.avaloq.tools.ddk.xtext.expression.expression.BooleanLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.BooleanOperation;
import com.avaloq.tools.ddk.xtext.expression.expression.Case;
import com.avaloq.tools.ddk.xtext.expression.expression.CastedExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ChainExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.CollectionExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ConstructorCallExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ExpressionPackage;
import com.avaloq.tools.ddk.xtext.expression.expression.FeatureCall;
import com.avaloq.tools.ddk.xtext.expression.expression.GlobalVarExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.Identifier;
import com.avaloq.tools.ddk.xtext.expression.expression.IfExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.IntegerLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.LetExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.ListLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.NullLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.OperationCall;
import com.avaloq.tools.ddk.xtext.expression.expression.RealLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.StringLiteral;
import com.avaloq.tools.ddk.xtext.expression.expression.SwitchExpression;
import com.avaloq.tools.ddk.xtext.expression.expression.TypeSelectExpression;
import com.avaloq.tools.ddk.xtext.expression.serializer.ExpressionSemanticSequencer;
import com.avaloq.tools.ddk.xtext.scope.scope.Extension;
import com.avaloq.tools.ddk.xtext.scope.scope.FactoryExpression;
import com.avaloq.tools.ddk.xtext.scope.scope.GlobalScopeExpression;
import com.avaloq.tools.ddk.xtext.scope.scope.Import;
import com.avaloq.tools.ddk.xtext.scope.scope.Injection;
import com.avaloq.tools.ddk.xtext.scope.scope.LambdaDataExpression;
import com.avaloq.tools.ddk.xtext.scope.scope.MatchDataExpression;
import com.avaloq.tools.ddk.xtext.scope.scope.Naming;
import com.avaloq.tools.ddk.xtext.scope.scope.NamingDefinition;
import com.avaloq.tools.ddk.xtext.scope.scope.NamingExpression;
import com.avaloq.tools.ddk.xtext.scope.scope.NamingSection;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopeContext;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopeDefinition;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopeDelegation;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopeModel;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopePackage;
import com.avaloq.tools.ddk.xtext.scope.scope.ScopeRule;
import com.avaloq.tools.ddk.xtext.scope.scope.SimpleScopeExpression;
import com.avaloq.tools.ddk.xtext.scope.services.ScopeGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractScopeSemanticSequencer extends ExpressionSemanticSequencer {

	@Inject
	private ScopeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_OPERATION:
				sequence_AndExpression_ImpliesExpression_OrExpression_RelationalExpression(context, (BooleanOperation) semanticObject); 
				return; 
			case ExpressionPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case ExpressionPackage.CASTED_EXPRESSION:
				sequence_CastedExpression(context, (CastedExpression) semanticObject); 
				return; 
			case ExpressionPackage.CHAIN_EXPRESSION:
				sequence_ChainExpression(context, (ChainExpression) semanticObject); 
				return; 
			case ExpressionPackage.COLLECTION_EXPRESSION:
				if (rule == grammarAccess.getFeatureCallRule()
						|| rule == grammarAccess.getCollectionExpressionRule()) {
					sequence_CollectionExpression(context, (CollectionExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getChainExpressionRule()
						|| action == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0()
						|| rule == grammarAccess.getChainedExpressionRule()
						|| rule == grammarAccess.getIfExpressionTriRule()
						|| action == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0()
						|| action == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_CollectionExpression_InfixExpression(context, (CollectionExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.CONSTRUCTOR_CALL_EXPRESSION:
				sequence_ConstructorCallExpression(context, (ConstructorCallExpression) semanticObject); 
				return; 
			case ExpressionPackage.FEATURE_CALL:
				if (rule == grammarAccess.getFeatureCallRule()) {
					sequence_FeatureCall(context, (FeatureCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getChainExpressionRule()
						|| action == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0()
						|| rule == grammarAccess.getChainedExpressionRule()
						|| rule == grammarAccess.getIfExpressionTriRule()
						|| action == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0()
						|| action == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_FeatureCall_InfixExpression(context, (FeatureCall) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.GLOBAL_VAR_EXPRESSION:
				sequence_GlobalVarExpression(context, (GlobalVarExpression) semanticObject); 
				return; 
			case ExpressionPackage.IDENTIFIER:
				if (rule == grammarAccess.getCollectionTypeRule()) {
					sequence_CollectionType(context, (Identifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getTypeRule()) {
					sequence_CollectionType_SimpleType(context, (Identifier) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleTypeRule()) {
					sequence_SimpleType(context, (Identifier) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.IF_EXPRESSION:
				if (rule == grammarAccess.getIfExpressionKwRule()) {
					sequence_IfExpressionKw(context, (IfExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getChainExpressionRule()
						|| action == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0()
						|| rule == grammarAccess.getChainedExpressionRule()
						|| rule == grammarAccess.getIfExpressionTriRule()
						|| action == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0()
						|| action == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_IfExpressionKw_IfExpressionTri(context, (IfExpression) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case ExpressionPackage.LET_EXPRESSION:
				sequence_LetExpression(context, (LetExpression) semanticObject); 
				return; 
			case ExpressionPackage.LIST_LITERAL:
				sequence_ListLiteral(context, (ListLiteral) semanticObject); 
				return; 
			case ExpressionPackage.NULL_LITERAL:
				sequence_NullLiteral(context, (NullLiteral) semanticObject); 
				return; 
			case ExpressionPackage.OPERATION_CALL:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getChainExpressionRule()
						|| action == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0()
						|| rule == grammarAccess.getChainedExpressionRule()
						|| rule == grammarAccess.getIfExpressionTriRule()
						|| action == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0()
						|| action == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_AdditiveExpression_InfixExpression_MultiplicativeExpression_OperationCall_UnaryExpression(context, (OperationCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureCallRule()
						|| rule == grammarAccess.getOperationCallRule()) {
					sequence_OperationCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryExpressionRule()) {
					sequence_UnaryExpression(context, (OperationCall) semanticObject); 
					return; 
				}
				else break;
			case ExpressionPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case ExpressionPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ExpressionPackage.SWITCH_EXPRESSION:
				sequence_SwitchExpression(context, (SwitchExpression) semanticObject); 
				return; 
			case ExpressionPackage.TYPE_SELECT_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getSyntaxElementRule()
						|| rule == grammarAccess.getChainExpressionRule()
						|| action == grammarAccess.getChainExpressionAccess().getChainExpressionFirstAction_1_0()
						|| rule == grammarAccess.getChainedExpressionRule()
						|| rule == grammarAccess.getIfExpressionTriRule()
						|| action == grammarAccess.getIfExpressionTriAccess().getIfExpressionConditionAction_1_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getImpliesExpressionRule()
						|| action == grammarAccess.getImpliesExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBooleanOperationLeftAction_1_0()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getOperationCallParamsAction_1_0()
						|| rule == grammarAccess.getUnaryOrInfixExpressionRule()
						|| rule == grammarAccess.getInfixExpressionRule()
						|| action == grammarAccess.getInfixExpressionAccess().getOperationCallTargetAction_1_0_0()
						|| action == grammarAccess.getInfixExpressionAccess().getFeatureCallTargetAction_1_1_0()
						|| action == grammarAccess.getInfixExpressionAccess().getTypeSelectExpressionTargetAction_1_2_0()
						|| action == grammarAccess.getInfixExpressionAccess().getCollectionExpressionTargetAction_1_3_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| rule == grammarAccess.getParanthesizedExpressionRule()) {
					sequence_InfixExpression_TypeSelectExpression(context, (TypeSelectExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getFeatureCallRule()
						|| rule == grammarAccess.getTypeSelectExpressionRule()) {
					sequence_TypeSelectExpression(context, (TypeSelectExpression) semanticObject); 
					return; 
				}
				else break;
			}
		else if (epackage == ScopePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScopePackage.EXTENSION:
				sequence_Extension(context, (Extension) semanticObject); 
				return; 
			case ScopePackage.FACTORY_EXPRESSION:
				sequence_FactoryExpression(context, (FactoryExpression) semanticObject); 
				return; 
			case ScopePackage.GLOBAL_SCOPE_EXPRESSION:
				if (rule == grammarAccess.getGlobalScopeExpressionRule()) {
					sequence_GlobalScopeExpression(context, (GlobalScopeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getScopeExpressionRule()
						|| rule == grammarAccess.getNamedScopeExpressionRule()) {
					sequence_GlobalScopeExpression_NamedScopeExpression(context, (GlobalScopeExpression) semanticObject); 
					return; 
				}
				else break;
			case ScopePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ScopePackage.INJECTION:
				sequence_Injection(context, (Injection) semanticObject); 
				return; 
			case ScopePackage.LAMBDA_DATA_EXPRESSION:
				sequence_LambdaDataExpression(context, (LambdaDataExpression) semanticObject); 
				return; 
			case ScopePackage.MATCH_DATA_EXPRESSION:
				sequence_MatchDataExpression(context, (MatchDataExpression) semanticObject); 
				return; 
			case ScopePackage.NAMING:
				sequence_Naming(context, (Naming) semanticObject); 
				return; 
			case ScopePackage.NAMING_DEFINITION:
				sequence_NamingDefinition(context, (NamingDefinition) semanticObject); 
				return; 
			case ScopePackage.NAMING_EXPRESSION:
				sequence_NamingExpression(context, (NamingExpression) semanticObject); 
				return; 
			case ScopePackage.NAMING_SECTION:
				sequence_NamingSection(context, (NamingSection) semanticObject); 
				return; 
			case ScopePackage.SCOPE_CONTEXT:
				sequence_ScopeContext(context, (ScopeContext) semanticObject); 
				return; 
			case ScopePackage.SCOPE_DEFINITION:
				sequence_ScopeDefinition(context, (ScopeDefinition) semanticObject); 
				return; 
			case ScopePackage.SCOPE_DELEGATION:
				sequence_ScopeDelegation(context, (ScopeDelegation) semanticObject); 
				return; 
			case ScopePackage.SCOPE_MODEL:
				sequence_ScopeModel(context, (ScopeModel) semanticObject); 
				return; 
			case ScopePackage.SCOPE_RULE:
				sequence_ScopeRule(context, (ScopeRule) semanticObject); 
				return; 
			case ScopePackage.SIMPLE_SCOPE_EXPRESSION:
				if (rule == grammarAccess.getScopeExpressionRule()
						|| rule == grammarAccess.getNamedScopeExpressionRule()) {
					sequence_NamedScopeExpression_SimpleScopeExpression(context, (SimpleScopeExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleScopeExpressionRule()) {
					sequence_SimpleScopeExpression(context, (SimpleScopeExpression) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Extension returns Extension
	 *
	 * Constraint:
	 *     extension=QualifiedID
	 */
	protected void sequence_Extension(ISerializationContext context, Extension semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.EXTENSION__EXTENSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.EXTENSION__EXTENSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtensionAccess().getExtensionQualifiedIDParserRuleCall_1_0(), semanticObject.getExtension());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScopeExpression returns FactoryExpression
	 *     FactoryExpression returns FactoryExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_FactoryExpression(ISerializationContext context, FactoryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.FACTORY_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.FACTORY_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFactoryExpressionAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GlobalScopeExpression returns GlobalScopeExpression
	 *
	 * Constraint:
	 *     (
	 *         type=[EClass|QualifiedID] 
	 *         (name=Expression | (recursivePrefix?='recursive'? prefix=Expression))? 
	 *         (data+=DataExpression data+=DataExpression*)? 
	 *         (domains+='*' | domains+=Identifier | (domains+=Identifier domains+=Identifier*))?
	 *     )
	 */
	protected void sequence_GlobalScopeExpression(ISerializationContext context, GlobalScopeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeExpression returns GlobalScopeExpression
	 *     NamedScopeExpression returns GlobalScopeExpression
	 *
	 * Constraint:
	 *     (
	 *         type=[EClass|QualifiedID] 
	 *         (name=Expression | (recursivePrefix?='recursive'? prefix=Expression))? 
	 *         (data+=DataExpression data+=DataExpression*)? 
	 *         (domains+='*' | domains+=Identifier | (domains+=Identifier domains+=Identifier*))? 
	 *         (caseDef?='case' casing=Casing)? 
	 *         naming=Naming?
	 *     )
	 */
	protected void sequence_GlobalScopeExpression_NamedScopeExpression(ISerializationContext context, GlobalScopeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     (package=[EPackage|STRING] name=Identifier?)
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Injection returns Injection
	 *
	 * Constraint:
	 *     (type=DottedID name=Identifier)
	 */
	protected void sequence_Injection(ISerializationContext context, Injection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.INJECTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.INJECTION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.INJECTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.INJECTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInjectionAccess().getTypeDottedIDParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getInjectionAccess().getNameIdentifierParserRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataExpression returns LambdaDataExpression
	 *     LambdaDataExpression returns LambdaDataExpression
	 *
	 * Constraint:
	 *     (desc=Identifier value=Expression)
	 */
	protected void sequence_LambdaDataExpression(ISerializationContext context, LambdaDataExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.LAMBDA_DATA_EXPRESSION__DESC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.LAMBDA_DATA_EXPRESSION__DESC));
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.DATA_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.DATA_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLambdaDataExpressionAccess().getDescIdentifierParserRuleCall_1_0(), semanticObject.getDesc());
		feeder.accept(grammarAccess.getLambdaDataExpressionAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DataExpression returns MatchDataExpression
	 *     MatchDataExpression returns MatchDataExpression
	 *
	 * Constraint:
	 *     (key=Identifier value=Expression)
	 */
	protected void sequence_MatchDataExpression(ISerializationContext context, MatchDataExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.MATCH_DATA_EXPRESSION__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.MATCH_DATA_EXPRESSION__KEY));
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.DATA_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.DATA_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchDataExpressionAccess().getKeyIdentifierParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getMatchDataExpressionAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ScopeExpression returns SimpleScopeExpression
	 *     NamedScopeExpression returns SimpleScopeExpression
	 *
	 * Constraint:
	 *     (expr=Expression (caseDef?='case' casing=Casing)? naming=Naming?)
	 */
	protected void sequence_NamedScopeExpression_SimpleScopeExpression(ISerializationContext context, SimpleScopeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamingDefinition returns NamingDefinition
	 *
	 * Constraint:
	 *     (type=[EClass|QualifiedID] naming=Naming)
	 */
	protected void sequence_NamingDefinition(ISerializationContext context, NamingDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.NAMING_DEFINITION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.NAMING_DEFINITION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.NAMING_DEFINITION__NAMING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.NAMING_DEFINITION__NAMING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamingDefinitionAccess().getTypeEClassQualifiedIDParserRuleCall_0_0_1(), semanticObject.eGet(ScopePackage.Literals.NAMING_DEFINITION__TYPE, false));
		feeder.accept(grammarAccess.getNamingDefinitionAccess().getNamingNamingParserRuleCall_2_0(), semanticObject.getNaming());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamingExpression returns NamingExpression
	 *
	 * Constraint:
	 *     (export?='export' | (factory?='factory'? expression=Expression))
	 */
	protected void sequence_NamingExpression(ISerializationContext context, NamingExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamingSection returns NamingSection
	 *
	 * Constraint:
	 *     (casing=Casing? namings+=NamingDefinition*)
	 */
	protected void sequence_NamingSection(ISerializationContext context, NamingSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Naming returns Naming
	 *
	 * Constraint:
	 *     ((names+=NamingExpression names+=NamingExpression*) | names+=NamingExpression)
	 */
	protected void sequence_Naming(ISerializationContext context, Naming semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeContext returns ScopeContext
	 *
	 * Constraint:
	 *     ((global?='*' | contextType=[EClass|QualifiedID]) guard=Expression?)
	 */
	protected void sequence_ScopeContext(ISerializationContext context, ScopeContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeDefinition returns ScopeDefinition
	 *
	 * Constraint:
	 *     (name=Identifier? (targetType=[EClass|QualifiedID] | (contextType=[EClass|QualifiedID] reference=[EReference|Identifier])) rules+=ScopeRule+)
	 */
	protected void sequence_ScopeDefinition(ISerializationContext context, ScopeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeExpression returns ScopeDelegation
	 *     ScopeDelegation returns ScopeDelegation
	 *
	 * Constraint:
	 *     ((delegate=Expression | external=GlobalScopeExpression) scope=[ScopeDefinition|Identifier]?)
	 */
	protected void sequence_ScopeDelegation(ISerializationContext context, ScopeDelegation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeModel returns ScopeModel
	 *
	 * Constraint:
	 *     (
	 *         name=DottedID 
	 *         includedScopes+=[ScopeModel|DottedID]? 
	 *         imports+=Import* 
	 *         extensions+=Extension* 
	 *         injections+=Injection* 
	 *         naming=NamingSection? 
	 *         scopes+=ScopeDefinition*
	 *     )
	 */
	protected void sequence_ScopeModel(ISerializationContext context, ScopeModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ScopeRule returns ScopeRule
	 *
	 * Constraint:
	 *     (context=ScopeContext exprs+=ScopeExpression exprs+=ScopeExpression*)
	 */
	protected void sequence_ScopeRule(ISerializationContext context, ScopeRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleScopeExpression returns SimpleScopeExpression
	 *
	 * Constraint:
	 *     expr=Expression
	 */
	protected void sequence_SimpleScopeExpression(ISerializationContext context, SimpleScopeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScopePackage.Literals.SIMPLE_SCOPE_EXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScopePackage.Literals.SIMPLE_SCOPE_EXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleScopeExpressionAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
}
