/*
 * generated by Xtext
 */
package com.avaloq.tools.ddk.check.serializer;

import com.avaloq.tools.ddk.check.check.Category;
import com.avaloq.tools.ddk.check.check.Check;
import com.avaloq.tools.ddk.check.check.CheckCatalog;
import com.avaloq.tools.ddk.check.check.CheckPackage;
import com.avaloq.tools.ddk.check.check.Context;
import com.avaloq.tools.ddk.check.check.ContextVariable;
import com.avaloq.tools.ddk.check.check.FormalParameter;
import com.avaloq.tools.ddk.check.check.Implementation;
import com.avaloq.tools.ddk.check.check.Member;
import com.avaloq.tools.ddk.check.check.SeverityRange;
import com.avaloq.tools.ddk.check.check.XGuardExpression;
import com.avaloq.tools.ddk.check.check.XIssueExpression;
import com.avaloq.tools.ddk.check.services.CheckGrammarAccess;
import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.annotations.serializer.XbaseWithAnnotationsSemanticSequencer;
import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotation;
import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotationElementValuePair;
import org.eclipse.xtext.xbase.annotations.xAnnotations.XAnnotationsPackage;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public abstract class AbstractCheckSemanticSequencer extends XbaseWithAnnotationsSemanticSequencer {

  @Inject
  private CheckGrammarAccess grammarAccess;

  @Override
  public void createSequence(EObject context, EObject semanticObject) {
  	if(semanticObject.eClass().getEPackage() == CheckPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
  		case CheckPackage.CATEGORY:
  			sequence_Category(context, (Category) semanticObject); 
  			return; 
  		case CheckPackage.CHECK:
  			sequence_Check(context, (Check) semanticObject); 
  			return; 
  		case CheckPackage.CHECK_CATALOG:
  			sequence_CheckCatalog(context, (CheckCatalog) semanticObject); 
  			return; 
  		case CheckPackage.CONTEXT:
  			sequence_Context(context, (Context) semanticObject); 
  			return; 
  		case CheckPackage.CONTEXT_VARIABLE:
  			sequence_ContextVariable(context, (ContextVariable) semanticObject); 
  			return; 
  		case CheckPackage.FORMAL_PARAMETER:
  			sequence_FormalParameter(context, (FormalParameter) semanticObject); 
  			return; 
  		case CheckPackage.IMPLEMENTATION:
  			sequence_Implementation(context, (Implementation) semanticObject); 
  			return; 
  		case CheckPackage.MEMBER:
  			sequence_Member(context, (Member) semanticObject); 
  			return; 
  		case CheckPackage.SEVERITY_RANGE:
  			sequence_SeverityRange(context, (SeverityRange) semanticObject); 
  			return; 
  		case CheckPackage.XGUARD_EXPRESSION:
  			sequence_XGuardExpression(context, (XGuardExpression) semanticObject); 
  			return; 
  		case CheckPackage.XISSUE_EXPRESSION:
  			sequence_XIssueExpression(context, (XIssueExpression) semanticObject); 
  			return; 
  		}
  	else if(semanticObject.eClass().getEPackage() == TypesPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
  		case TypesPackage.JVM_FORMAL_PARAMETER:
  			if(context == grammarAccess.getFullJvmFormalParameterRule()) {
  				sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getJvmFormalParameterRule()) {
  				sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
  				return; 
  			}
  			else break;
  		case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
  			sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
  			return; 
  		case TypesPackage.JVM_INNER_TYPE_REFERENCE:
  			sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
  			return; 
  		case TypesPackage.JVM_LOWER_BOUND:
  			if(context == grammarAccess.getJvmLowerBoundAndedRule()) {
  				sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getJvmLowerBoundRule()) {
  				sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
  				return; 
  			}
  			else break;
  		case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
  			sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
  			return; 
  		case TypesPackage.JVM_TYPE_PARAMETER:
  			sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
  			return; 
  		case TypesPackage.JVM_UPPER_BOUND:
  			if(context == grammarAccess.getJvmUpperBoundAndedRule()) {
  				sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getJvmUpperBoundRule()) {
  				sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
  				return; 
  			}
  			else break;
  		case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
  			sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
  			return; 
  		}
  	else if(semanticObject.eClass().getEPackage() == XAnnotationsPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
  		case XAnnotationsPackage.XANNOTATION:
  			sequence_XAnnotation(context, (XAnnotation) semanticObject); 
  			return; 
  		case XAnnotationsPackage.XANNOTATION_ELEMENT_VALUE_PAIR:
  			sequence_XAnnotationElementValuePair(context, (XAnnotationElementValuePair) semanticObject); 
  			return; 
  		}
  	else if(semanticObject.eClass().getEPackage() == XbasePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
  		case XbasePackage.XASSIGNMENT:
  			sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
  			return; 
  		case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
  			sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
  			return; 
  		case XbasePackage.XBINARY_OPERATION:
  			sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
  			return; 
  		case XbasePackage.XBLOCK_EXPRESSION:
  			if(context == grammarAccess.getXAdditiveExpressionRule() ||
  			   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAndExpressionRule() ||
  			   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAnnotationElementValueRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListAccess().getXListLiteralElementsAction_1_1_0() ||
  			   context == grammarAccess.getXAnnotationOrExpressionRule() ||
  			   context == grammarAccess.getXAssignmentRule() ||
  			   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXBlockExpressionRule() ||
  			   context == grammarAccess.getXCastedExpressionRule() ||
  			   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
  			   context == grammarAccess.getXEqualityExpressionRule() ||
  			   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXExpressionRule() ||
  			   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
  			   context == grammarAccess.getXMemberFeatureCallRule() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXMultiplicativeExpressionRule() ||
  			   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOrExpressionRule() ||
  			   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOtherOperatorExpressionRule() ||
  			   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXParenthesizedExpressionRule() ||
  			   context == grammarAccess.getXPostfixOperationRule() ||
  			   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
  			   context == grammarAccess.getXPrimaryExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXUnaryOperationRule()) {
  				sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXExpressionInClosureRule()) {
  				sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
  				return; 
  			}
  			else break;
  		case XbasePackage.XBOOLEAN_LITERAL:
  			sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XCASE_PART:
  			sequence_XCasePart(context, (XCasePart) semanticObject); 
  			return; 
  		case XbasePackage.XCASTED_EXPRESSION:
  			sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
  			return; 
  		case XbasePackage.XCATCH_CLAUSE:
  			sequence_XCatchClause(context, (XCatchClause) semanticObject); 
  			return; 
  		case XbasePackage.XCLOSURE:
  			if(context == grammarAccess.getXAdditiveExpressionRule() ||
  			   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAndExpressionRule() ||
  			   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAnnotationElementValueRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListAccess().getXListLiteralElementsAction_1_1_0() ||
  			   context == grammarAccess.getXAnnotationOrExpressionRule() ||
  			   context == grammarAccess.getXAssignmentRule() ||
  			   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXCastedExpressionRule() ||
  			   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
  			   context == grammarAccess.getXClosureRule() ||
  			   context == grammarAccess.getXEqualityExpressionRule() ||
  			   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXExpressionRule() ||
  			   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
  			   context == grammarAccess.getXLiteralRule() ||
  			   context == grammarAccess.getXMemberFeatureCallRule() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXMultiplicativeExpressionRule() ||
  			   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOrExpressionRule() ||
  			   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOtherOperatorExpressionRule() ||
  			   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXParenthesizedExpressionRule() ||
  			   context == grammarAccess.getXPostfixOperationRule() ||
  			   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
  			   context == grammarAccess.getXPrimaryExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXUnaryOperationRule()) {
  				sequence_XClosure(context, (XClosure) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXShortClosureRule()) {
  				sequence_XShortClosure(context, (XClosure) semanticObject); 
  				return; 
  			}
  			else break;
  		case XbasePackage.XCONSTRUCTOR_CALL:
  			sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
  			return; 
  		case XbasePackage.XDO_WHILE_EXPRESSION:
  			sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
  			return; 
  		case XbasePackage.XFEATURE_CALL:
  			sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
  			return; 
  		case XbasePackage.XFOR_LOOP_EXPRESSION:
  			sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
  			return; 
  		case XbasePackage.XIF_EXPRESSION:
  			sequence_XIfExpression(context, (XIfExpression) semanticObject); 
  			return; 
  		case XbasePackage.XINSTANCE_OF_EXPRESSION:
  			sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
  			return; 
  		case XbasePackage.XLIST_LITERAL:
  			if(context == grammarAccess.getXAnnotationElementValueOrCommaListRule()) {
  				sequence_XAnnotationElementValueOrCommaList_XListLiteral(context, (XListLiteral) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXAnnotationElementValueRule()) {
  				sequence_XAnnotationElementValue_XListLiteral(context, (XListLiteral) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXConstantListLiteralRule() ||
  			   context == grammarAccess.getXFormalParameterDefaultValueLiteralRule()) {
  				sequence_XConstantListLiteral(context, (XListLiteral) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXAdditiveExpressionRule() ||
  			   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAndExpressionRule() ||
  			   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListAccess().getXListLiteralElementsAction_1_1_0() ||
  			   context == grammarAccess.getXAnnotationOrExpressionRule() ||
  			   context == grammarAccess.getXAssignmentRule() ||
  			   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXCastedExpressionRule() ||
  			   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
  			   context == grammarAccess.getXCollectionLiteralRule() ||
  			   context == grammarAccess.getXEqualityExpressionRule() ||
  			   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXExpressionRule() ||
  			   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
  			   context == grammarAccess.getXListLiteralRule() ||
  			   context == grammarAccess.getXLiteralRule() ||
  			   context == grammarAccess.getXMemberFeatureCallRule() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXMultiplicativeExpressionRule() ||
  			   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOrExpressionRule() ||
  			   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOtherOperatorExpressionRule() ||
  			   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXParenthesizedExpressionRule() ||
  			   context == grammarAccess.getXPostfixOperationRule() ||
  			   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
  			   context == grammarAccess.getXPrimaryExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXUnaryOperationRule()) {
  				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
  				return; 
  			}
  			else break;
  		case XbasePackage.XMEMBER_FEATURE_CALL:
  			sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
  			return; 
  		case XbasePackage.XNULL_LITERAL:
  			sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XNUMBER_LITERAL:
  			sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XPOSTFIX_OPERATION:
  			sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
  			return; 
  		case XbasePackage.XRETURN_EXPRESSION:
  			sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
  			return; 
  		case XbasePackage.XSET_LITERAL:
  			sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XSTRING_LITERAL:
  			sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XSWITCH_EXPRESSION:
  			sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
  			return; 
  		case XbasePackage.XSYNCHRONIZED_EXPRESSION:
  			sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
  			return; 
  		case XbasePackage.XTHROW_EXPRESSION:
  			sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
  			return; 
  		case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
  			sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
  			return; 
  		case XbasePackage.XTYPE_LITERAL:
  			sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
  			return; 
  		case XbasePackage.XUNARY_OPERATION:
  			if(context == grammarAccess.getXConstantUnaryOperationRule() ||
  			   context == grammarAccess.getXFormalParameterDefaultValueLiteralRule()) {
  				sequence_XConstantUnaryOperation(context, (XUnaryOperation) semanticObject); 
  				return; 
  			}
  			else if(context == grammarAccess.getXAdditiveExpressionRule() ||
  			   context == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAndExpressionRule() ||
  			   context == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXAnnotationElementValueRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListRule() ||
  			   context == grammarAccess.getXAnnotationElementValueOrCommaListAccess().getXListLiteralElementsAction_1_1_0() ||
  			   context == grammarAccess.getXAnnotationOrExpressionRule() ||
  			   context == grammarAccess.getXAssignmentRule() ||
  			   context == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXCastedExpressionRule() ||
  			   context == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0() ||
  			   context == grammarAccess.getXEqualityExpressionRule() ||
  			   context == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXExpressionRule() ||
  			   context == grammarAccess.getXExpressionOrVarDeclarationRule() ||
  			   context == grammarAccess.getXMemberFeatureCallRule() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXMultiplicativeExpressionRule() ||
  			   context == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOrExpressionRule() ||
  			   context == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXOtherOperatorExpressionRule() ||
  			   context == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0() ||
  			   context == grammarAccess.getXParenthesizedExpressionRule() ||
  			   context == grammarAccess.getXPostfixOperationRule() ||
  			   context == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0() ||
  			   context == grammarAccess.getXPrimaryExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionRule() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0() ||
  			   context == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0() ||
  			   context == grammarAccess.getXUnaryOperationRule()) {
  				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
  				return; 
  			}
  			else break;
  		case XbasePackage.XVARIABLE_DECLARATION:
  			sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
  			return; 
  		case XbasePackage.XWHILE_EXPRESSION:
  			sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
  			return; 
  		}
  	else if(semanticObject.eClass().getEPackage() == XtypePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
  		case XtypePackage.XFUNCTION_TYPE_REF:
  			sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
  			return; 
  		case XtypePackage.XIMPORT_DECLARATION:
  			sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
  			return; 
  		case XtypePackage.XIMPORT_SECTION:
  			sequence_XImportSection(context, (XImportSection) semanticObject); 
  			return; 
  		}
  	if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
  }

  /**
   * Constraint:
   *     (id=ValidID? label=STRING checks+=Check*)
   */
  protected void sequence_Category(EObject context, Category semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         packageName=QualifiedName 
   *         imports=XImportSection 
   *         final?='final'? 
   *         name=ValidID 
   *         grammar=[Grammar|QualifiedName]? 
   *         (categories+=Category | implementations+=Implementation | checks+=Check | members+=Member)*
   *     )
   */
  protected void sequence_CheckCatalog(EObject context, CheckCatalog semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         severityRange=SeverityRange? 
   *         final?='final'? 
   *         kind=TriggerKind? 
   *         defaultSeverity=SeverityKind 
   *         id=ValidID? 
   *         label=STRING 
   *         (formalParameters+=FormalParameter formalParameters+=FormalParameter*)? 
   *         givenMessage=STRING? 
   *         (contexts+=Context* | contexts+=Context?)
   *     )
   */
  protected void sequence_Check(EObject context, Check semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (type=JvmTypeReference name=ValidID?)
   */
  protected void sequence_ContextVariable(EObject context, ContextVariable semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (contextVariable=ContextVariable constraint=XBlockExpression)
   */
  protected void sequence_Context(EObject context, Context semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (type=JvmParameterizedTypeReference name=ValidID right=XFormalParameterDefaultValueLiteral label=STRING?)
   */
  protected void sequence_FormalParameter(EObject context, FormalParameter semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (name=ValidID context=Context)
   */
  protected void sequence_Implementation(EObject context, Implementation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (annotations+=XAnnotation* type=JvmTypeReference name=ValidID value=XOrExpression?)
   */
  protected void sequence_Member(EObject context, Member semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (minSeverity=SeverityKind maxSeverity=SeverityKind)
   */
  protected void sequence_SeverityRange(EObject context, SeverityRange semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, CheckPackage.Literals.SEVERITY_RANGE__MIN_SEVERITY) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CheckPackage.Literals.SEVERITY_RANGE__MIN_SEVERITY));
  		if(transientValues.isValueTransient(semanticObject, CheckPackage.Literals.SEVERITY_RANGE__MAX_SEVERITY) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CheckPackage.Literals.SEVERITY_RANGE__MAX_SEVERITY));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getSeverityRangeAccess().getMinSeveritySeverityKindEnumRuleCall_3_0(), semanticObject.getMinSeverity());
  	feeder.accept(grammarAccess.getSeverityRangeAccess().getMaxSeveritySeverityKindEnumRuleCall_5_0(), semanticObject.getMaxSeverity());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (
   *         (leftOperand=XAdditiveExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpAdd] rightOperand=XMultiplicativeExpression) | 
   *         (leftOperand=XMultiplicativeExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpMulti] rightOperand=XUnaryOperation) | 
   *         (leftOperand=XOtherOperatorExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpOther] rightOperand=XAdditiveExpression) | 
   *         (leftOperand=XRelationalExpression_XBinaryOperation_1_1_0_0_0 feature=[JvmIdentifiableElement|OpCompare] rightOperand=XOtherOperatorExpression) | 
   *         (leftOperand=XEqualityExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpEquality] rightOperand=XRelationalExpression) | 
   *         (leftOperand=XAndExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpAnd] rightOperand=XEqualityExpression) | 
   *         (leftOperand=XOrExpression_XBinaryOperation_1_0_0_0 feature=[JvmIdentifiableElement|OpOr] rightOperand=XAndExpression) | 
   *         (leftOperand=XAssignment_XBinaryOperation_1_1_0_0_0 feature=[JvmIdentifiableElement|OpMultiAssign] rightOperand=XAssignment)
   *     )
   */
  protected void sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(EObject context, XBinaryOperation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         ((elements+=XAnnotationOrExpression elements+=XAnnotationOrExpression*)?) | 
   *         (elements+=XAnnotationElementValueOrCommaList_XListLiteral_1_1_0 elements+=XAnnotationOrExpression+) | 
   *         ((elements+=XExpression elements+=XExpression*)?)
   *     )
   */
  protected void sequence_XAnnotationElementValueOrCommaList_XListLiteral(EObject context, XListLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (element=[JvmOperation|ValidID] value=XAnnotationElementValue)
   */
  protected void sequence_XAnnotationElementValuePair(EObject context, XAnnotationElementValuePair semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XAnnotationsPackage.Literals.XANNOTATION_ELEMENT_VALUE_PAIR__VALUE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XAnnotationsPackage.Literals.XANNOTATION_ELEMENT_VALUE_PAIR__VALUE));
  		if(transientValues.isValueTransient(semanticObject, XAnnotationsPackage.Literals.XANNOTATION_ELEMENT_VALUE_PAIR__ELEMENT) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XAnnotationsPackage.Literals.XANNOTATION_ELEMENT_VALUE_PAIR__ELEMENT));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXAnnotationElementValuePairAccess().getElementJvmOperationValidIDParserRuleCall_0_0_0_0_1(), semanticObject.getElement());
  	feeder.accept(grammarAccess.getXAnnotationElementValuePairAccess().getValueXAnnotationElementValueParserRuleCall_1_0(), semanticObject.getValue());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (((elements+=XAnnotationOrExpression elements+=XAnnotationOrExpression*)?) | ((elements+=XExpression elements+=XExpression*)?))
   */
  protected void sequence_XAnnotationElementValue_XListLiteral(EObject context, XListLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         annotationType=[JvmAnnotationType|QualifiedName] 
   *         ((elementValuePairs+=XAnnotationElementValuePair elementValuePairs+=XAnnotationElementValuePair*) | value=XAnnotationElementValueOrCommaList)?
   *     )
   */
  protected void sequence_XAnnotation(EObject context, XAnnotation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         (feature=[JvmIdentifiableElement|FeatureCallID] value=XAssignment) | 
   *         (assignable=XMemberFeatureCall_XAssignment_1_0_0_0_0 explicitStatic?='::'? feature=[JvmIdentifiableElement|FeatureCallID] value=XAssignment)
   *     )
   */
  protected void sequence_XAssignment_XMemberFeatureCall(EObject context, XAssignment semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         (initExpressions+=XExpressionOrVarDeclaration initExpressions+=XExpressionOrVarDeclaration*)? 
   *         expression=XExpression? 
   *         (updateExpressions+=XExpression updateExpressions+=XExpression*)? 
   *         eachExpression=XExpression
   *     )
   */
  protected void sequence_XBasicForLoopExpression(EObject context, XBasicForLoopExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (expressions+=XExpressionOrVarDeclaration*)
   */
  protected void sequence_XBlockExpression(EObject context, XBlockExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (isTrue?='true'?)
   */
  protected void sequence_XBooleanLiteral(EObject context, XBooleanLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (typeGuard=JvmTypeReference? case=XExpression? (then=XExpression | fallThrough?=','))
   */
  protected void sequence_XCasePart(EObject context, XCasePart semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (target=XCastedExpression_XCastedExpression_1_0_0_0 type=JvmTypeReference)
   */
  protected void sequence_XCastedExpression(EObject context, XCastedExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XCASTED_EXPRESSION__TYPE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XCASTED_EXPRESSION__TYPE));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XCASTED_EXPRESSION__TARGET) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XCASTED_EXPRESSION__TARGET));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0(), semanticObject.getTarget());
  	feeder.accept(grammarAccess.getXCastedExpressionAccess().getTypeJvmTypeReferenceParserRuleCall_1_1_0(), semanticObject.getType());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (declaredParam=FullJvmFormalParameter expression=XExpression)
   */
  protected void sequence_XCatchClause(EObject context, XCatchClause semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XCATCH_CLAUSE__EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XCATCH_CLAUSE__EXPRESSION));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XCATCH_CLAUSE__DECLARED_PARAM) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XCATCH_CLAUSE__DECLARED_PARAM));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXCatchClauseAccess().getDeclaredParamFullJvmFormalParameterParserRuleCall_2_0(), semanticObject.getDeclaredParam());
  	feeder.accept(grammarAccess.getXCatchClauseAccess().getExpressionXExpressionParserRuleCall_4_0(), semanticObject.getExpression());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (
   *         ((declaredFormalParameters+=JvmFormalParameter declaredFormalParameters+=JvmFormalParameter*)? explicitSyntax?='|')? 
   *         expression=XExpressionInClosure
   *     )
   */
  protected void sequence_XClosure(EObject context, XClosure semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     ((elements+=XConstantUnaryOperation elements+=XConstantUnaryOperation*)?)
   */
  protected void sequence_XConstantListLiteral(EObject context, XListLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (feature=[JvmIdentifiableElement|OpUnary] operand=XConstantUnaryOperation)
   */
  protected void sequence_XConstantUnaryOperation(EObject context, XUnaryOperation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         constructor=[JvmConstructor|QualifiedName] 
   *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
   *         (explicitConstructorCall?='(' (arguments+=XShortClosure | (arguments+=XExpression arguments+=XExpression*))?)? 
   *         arguments+=XClosure?
   *     )
   */
  protected void sequence_XConstructorCall(EObject context, XConstructorCall semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (body=XExpression predicate=XExpression)
   */
  protected void sequence_XDoWhileExpression(EObject context, XDoWhileExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXDoWhileExpressionAccess().getBodyXExpressionParserRuleCall_2_0(), semanticObject.getBody());
  	feeder.accept(grammarAccess.getXDoWhileExpressionAccess().getPredicateXExpressionParserRuleCall_5_0(), semanticObject.getPredicate());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (expressions+=XExpressionOrVarDeclaration*)
   */
  protected void sequence_XExpressionInClosure(EObject context, XBlockExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
   *         feature=[JvmIdentifiableElement|IdOrSuper] 
   *         (explicitOperationCall?='(' (featureCallArguments+=XShortClosure | (featureCallArguments+=XExpression featureCallArguments+=XExpression*))?)? 
   *         featureCallArguments+=XClosure?
   *     )
   */
  protected void sequence_XFeatureCall(EObject context, XFeatureCall semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (declaredParam=JvmFormalParameter forExpression=XExpression eachExpression=XExpression)
   */
  protected void sequence_XForLoopExpression(EObject context, XForLoopExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__FOR_EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__FOR_EXPRESSION));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__EACH_EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__EACH_EXPRESSION));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__DECLARED_PARAM) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XFOR_LOOP_EXPRESSION__DECLARED_PARAM));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXForLoopExpressionAccess().getDeclaredParamJvmFormalParameterParserRuleCall_0_0_3_0(), semanticObject.getDeclaredParam());
  	feeder.accept(grammarAccess.getXForLoopExpressionAccess().getForExpressionXExpressionParserRuleCall_1_0(), semanticObject.getForExpression());
  	feeder.accept(grammarAccess.getXForLoopExpressionAccess().getEachExpressionXExpressionParserRuleCall_3_0(), semanticObject.getEachExpression());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     ((paramTypes+=JvmTypeReference paramTypes+=JvmTypeReference*)? returnType=JvmTypeReference)
   */
  protected void sequence_XFunctionTypeRef(EObject context, XFunctionTypeRef semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     guard=XExpression
   */
  protected void sequence_XGuardExpression(EObject context, XGuardExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, CheckPackage.Literals.XGUARD_EXPRESSION__GUARD) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CheckPackage.Literals.XGUARD_EXPRESSION__GUARD));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXGuardExpressionAccess().getGuardXExpressionParserRuleCall_2_0(), semanticObject.getGuard());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (if=XExpression then=XExpression else=XExpression?)
   */
  protected void sequence_XIfExpression(EObject context, XIfExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (importedType=[JvmDeclaredType|QualifiedName] | importedNamespace=QualifiedNameWithWildcard)
   */
  protected void sequence_XImportDeclaration(EObject context, XImportDeclaration semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (importDeclarations+=XImportDeclaration*)
   */
  protected void sequence_XImportSection(EObject context, XImportSection semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         check=[Check|QualifiedName]? 
   *         (
   *             (markerFeature=[EStructuralFeature|ValidID] | (markerObject=XExpression markerFeature=[EStructuralFeature|FeatureCallID]?)) 
   *             markerIndex=XExpression?
   *         )? 
   *         message=XExpression? 
   *         (messageParameters+=XExpression messageParameters+=XExpression*)? 
   *         (issueCode=ValidID? issueData+=XExpression issueData+=XExpression*)?
   *     )
   */
  protected void sequence_XIssueExpression(EObject context, XIssueExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     ((elements+=XExpression elements+=XExpression*)?)
   */
  protected void sequence_XListLiteral(EObject context, XListLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (
   *         memberCallTarget=XMemberFeatureCall_XMemberFeatureCall_1_1_0_0_0 
   *         (nullSafe?='?.' | explicitStatic?='::')? 
   *         (typeArguments+=JvmArgumentTypeReference typeArguments+=JvmArgumentTypeReference*)? 
   *         feature=[JvmIdentifiableElement|IdOrSuper] 
   *         (explicitOperationCall?='(' (memberCallArguments+=XShortClosure | (memberCallArguments+=XExpression memberCallArguments+=XExpression*))?)? 
   *         memberCallArguments+=XClosure?
   *     )
   */
  protected void sequence_XMemberFeatureCall(EObject context, XMemberFeatureCall semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     {XNullLiteral}
   */
  protected void sequence_XNullLiteral(EObject context, XNullLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     value=Number
   */
  protected void sequence_XNumberLiteral(EObject context, XNumberLiteral semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XNUMBER_LITERAL__VALUE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XNUMBER_LITERAL__VALUE));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXNumberLiteralAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (operand=XPostfixOperation_XPostfixOperation_1_0_0 feature=[JvmIdentifiableElement|OpPostfix])
   */
  protected void sequence_XPostfixOperation(EObject context, XPostfixOperation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (expression=XRelationalExpression_XInstanceOfExpression_1_0_0_0_0 type=JvmTypeReference)
   */
  protected void sequence_XRelationalExpression(EObject context, XInstanceOfExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XINSTANCE_OF_EXPRESSION__TYPE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XINSTANCE_OF_EXPRESSION__TYPE));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XINSTANCE_OF_EXPRESSION__EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XINSTANCE_OF_EXPRESSION__EXPRESSION));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0(), semanticObject.getExpression());
  	feeder.accept(grammarAccess.getXRelationalExpressionAccess().getTypeJvmTypeReferenceParserRuleCall_1_0_1_0(), semanticObject.getType());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (expression=XExpression?)
   */
  protected void sequence_XReturnExpression(EObject context, XReturnExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     ((elements+=XExpression elements+=XExpression*)?)
   */
  protected void sequence_XSetLiteral(EObject context, XSetLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     ((declaredFormalParameters+=JvmFormalParameter declaredFormalParameters+=JvmFormalParameter*)? explicitSyntax?='|' expression=XExpression)
   */
  protected void sequence_XShortClosure(EObject context, XClosure semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     value=STRING
   */
  protected void sequence_XStringLiteral(EObject context, XStringLiteral semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XSTRING_LITERAL__VALUE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XSTRING_LITERAL__VALUE));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (
   *         ((declaredParam=JvmFormalParameter switch=XExpression) | (declaredParam=JvmFormalParameter? switch=XExpression)) 
   *         cases+=XCasePart* 
   *         default=XExpression?
   *     )
   */
  protected void sequence_XSwitchExpression(EObject context, XSwitchExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (param=XExpression expression=XExpression)
   */
  protected void sequence_XSynchronizedExpression(EObject context, XSynchronizedExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__PARAM) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__PARAM));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XSYNCHRONIZED_EXPRESSION__EXPRESSION));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXSynchronizedExpressionAccess().getParamXExpressionParserRuleCall_1_0(), semanticObject.getParam());
  	feeder.accept(grammarAccess.getXSynchronizedExpressionAccess().getExpressionXExpressionParserRuleCall_3_0(), semanticObject.getExpression());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     expression=XExpression
   */
  protected void sequence_XThrowExpression(EObject context, XThrowExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XTHROW_EXPRESSION__EXPRESSION) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XTHROW_EXPRESSION__EXPRESSION));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXThrowExpressionAccess().getExpressionXExpressionParserRuleCall_2_0(), semanticObject.getExpression());
  	feeder.finish();
  }
  
  
  /**
   * Constraint:
   *     (expression=XExpression ((catchClauses+=XCatchClause+ finallyExpression=XExpression?) | finallyExpression=XExpression))
   */
  protected void sequence_XTryCatchFinallyExpression(EObject context, XTryCatchFinallyExpression semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (type=[JvmType|QualifiedName] arrayDimensions+=ArrayBrackets*)
   */
  protected void sequence_XTypeLiteral(EObject context, XTypeLiteral semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (feature=[JvmIdentifiableElement|OpUnary] operand=XUnaryOperation)
   */
  protected void sequence_XUnaryOperation(EObject context, XUnaryOperation semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (writeable?='var'? ((type=JvmTypeReference name=ValidID) | name=ValidID) right=XExpression?)
   */
  protected void sequence_XVariableDeclaration(EObject context, XVariableDeclaration semanticObject) {
  	genericSequencer.createSequence(context, semanticObject);
  }
  
  
  /**
   * Constraint:
   *     (predicate=XExpression body=XExpression)
   */
  protected void sequence_XWhileExpression(EObject context, XWhileExpression semanticObject) {
  	if(errorAcceptor != null) {
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__PREDICATE));
  		if(transientValues.isValueTransient(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY) == ValueTransient.YES)
  			errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XbasePackage.Literals.XABSTRACT_WHILE_EXPRESSION__BODY));
  	}
  	INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
  	SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
  	feeder.accept(grammarAccess.getXWhileExpressionAccess().getPredicateXExpressionParserRuleCall_3_0(), semanticObject.getPredicate());
  	feeder.accept(grammarAccess.getXWhileExpressionAccess().getBodyXExpressionParserRuleCall_5_0(), semanticObject.getBody());
  	feeder.finish();
  }
}
